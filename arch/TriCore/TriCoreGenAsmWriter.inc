/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#include <stdio.h>	// debug
#include <platform.h>


/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
static void printInstruction(MCInst *MI, SStream *O, MCRegisterInfo *MRI)
{
  static const uint32_t OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    423U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    416U,	// BUNDLE
    450U,	// LIFETIME_START
    403U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_LOAD_OP
    1305U,	// ABS
    132176U,	// ADDArr
    656521U,	// ADDCrc
    132233U,	// ADDCrr
    132313U,	// ADDIrlc
    656772U,	// ADDXrc
    132484U,	// ADDXrr
    495U,	// ADDi64
    509U,	// ADDi64C
    132258U,	// ADDrc
    132258U,	// ADDrr
    17570U,	// ADDsrc
    33954U,	// ADDsrr
    9251U,	// ADJCALLSTACKDOWN
    9271U,	// ADJCALLSTACKUP
    263412U,	// ANDNrc
    465U,	// ANDNrc64
    1213695U,	// AND_EQrc
    1737983U,	// AND_EQrr
    2262322U,	// AND_GEUrc
    1738034U,	// AND_GE_Urr
    1213613U,	// AND_GErc
    2262341U,	// AND_LTUrc
    1738053U,	// AND_LT_Urr
    1213726U,	// AND_LTrc
    2753704U,	// ANDrc
    465U,	// ANDrc64
    132264U,	// ANDrr
    2062U,	// ANDsc
    33960U,	// ANDsrr
    465U,	// ANDsrr64
    9449U,	// CALLb
    4326674U,	// DEXTRrrpw
    656643U,	// EQrc
    132355U,	// EQrr
    4326675U,	// EXTRrrpw
    656561U,	// GErc
    132273U,	// GErr
    50402U,	// IMASKrcpw
    3470U,	// JNZsbr
    3466U,	// JZsbr
    4319U,	// Jb
    66911U,	// LDBUbo
    66673U,	// LDBbo
    66703U,	// LDDbo
    66918U,	// LDHUbo
    66755U,	// LDHbo
    66930U,	// LDWbo
    656674U,	// LTrc
    132386U,	// LTrr
    1124U,	// MOVAArr
    1124U,	// MOVAAsrr
    1117U,	// MOVArr
    1179U,	// MOVDrr
    1235U,	// MOVHrlc
    83288U,	// MOVUrlc
    465U,	// MOVi32
    99693U,	// MOVrlc
    1389U,	// MOVrr
    116077U,	// MOVsrc
    656623U,	// MULrc
    132335U,	// MULrr2
    34031U,	// MULsrr
    2753703U,	// NANDrc
    132263U,	// NANDrr
    656575U,	// NErc
    132287U,	// NErr
    2753800U,	// NORrc
    132360U,	// NORrr
    465U,	// NOTrr64
    9517U,	// NOTsr
    263418U,	// ORNrc
    465U,	// ORNrc64
    2262332U,	// OR_GEUrc
    1213621U,	// OR_GErc
    1737909U,	// OR_GErr
    2262351U,	// OR_LTUrc
    1213734U,	// OR_LTrc
    1738022U,	// OR_LTrr
    1213628U,	// OR_NErc
    1737916U,	// OR_NErr
    2753801U,	// ORrc
    465U,	// ORrc64
    132361U,	// ORrr
    2073U,	// ORsc
    34057U,	// ORsrr
    465U,	// ORsrr64
    524U,	// RET
    656509U,	// RSUBrc
    9341U,	// RSUBsr
    656492U,	// SHArc
    132204U,	// SHArr
    656591U,	// SHrc
    132303U,	// SHrr
    5207U,	// STAbo
    5239U,	// STBbo
    5269U,	// STDbo
    5321U,	// STHbo
    5496U,	// STWbo
    132169U,	// SUBArr
    2049U,	// SUBAsc
    132227U,	// SUBCrr
    132478U,	// SUBXrr
    481U,	// SUBi64
    433U,	// Select8
    263431U,	// XNORrc
    2753805U,	// XORrc
    465U,	// XORrc64
    465U,	// XORrcneg64
    132365U,	// XORrr
    132365U,	// XORsrr
    465U,	// XORsrr64
    0U
  };

  static char AsmStrs[] = {
  /* 0 */ 's', 'u', 'b', '.', 'a', 32, '%', 'a', '1', '0', ',', 32, 0,
  /* 13 */ 'a', 'n', 'd', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 24 */ 'o', 'r', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 34 */ '#', 32, 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 32, 0,
  /* 54 */ '#', 32, 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 32, 0,
  /* 72 */ 's', 'u', 'b', '.', 'a', 32, 0,
  /* 79 */ 'a', 'd', 'd', '.', 'a', 32, 0,
  /* 86 */ 's', 't', '.', 'a', 32, 0,
  /* 92 */ 'm', 'o', 'v', '.', 'a', 32, 0,
  /* 99 */ 'm', 'o', 'v', '.', 'a', 'a', 32, 0,
  /* 107 */ 's', 'h', 'a', 32, 0,
  /* 112 */ 'l', 'd', '.', 'b', 32, 0,
  /* 118 */ 's', 't', '.', 'b', 32, 0,
  /* 124 */ 'r', 's', 'u', 'b', 32, 0,
  /* 130 */ 's', 'u', 'b', 'c', 32, 0,
  /* 136 */ 'a', 'd', 'd', 'c', 32, 0,
  /* 142 */ 'l', 'd', '.', 'd', 32, 0,
  /* 148 */ 's', 't', '.', 'd', 32, 0,
  /* 154 */ 'm', 'o', 'v', '.', 'd', 32, 0,
  /* 161 */ 'a', 'd', 'd', 32, 0,
  /* 166 */ 'n', 'a', 'n', 'd', 32, 0,
  /* 172 */ 'a', 'n', 'd', '.', 'g', 'e', 32, 0,
  /* 180 */ 'o', 'r', '.', 'g', 'e', 32, 0,
  /* 187 */ 'o', 'r', '.', 'n', 'e', 32, 0,
  /* 194 */ 'l', 'd', '.', 'h', 32, 0,
  /* 200 */ 's', 't', '.', 'h', 32, 0,
  /* 206 */ 's', 'h', 32, 0,
  /* 210 */ 'm', 'o', 'v', 'h', 32, 0,
  /* 216 */ 'a', 'd', 'd', 'i', 32, 0,
  /* 222 */ 'j', 32, 0,
  /* 225 */ 'i', 'm', 'a', 's', 'k', 32, 0,
  /* 232 */ 'c', 'a', 'l', 'l', 32, 0,
  /* 238 */ 'm', 'u', 'l', 32, 0,
  /* 243 */ 'a', 'n', 'd', 'n', 32, 0,
  /* 249 */ 'o', 'r', 'n', 32, 0,
  /* 254 */ 'a', 'n', 'd', '.', 'e', 'q', 32, 0,
  /* 262 */ 'x', 'n', 'o', 'r', 32, 0,
  /* 268 */ 'x', 'o', 'r', 32, 0,
  /* 273 */ 'd', 'e', 'x', 't', 'r', 32, 0,
  /* 280 */ 'a', 'b', 's', 32, 0,
  /* 285 */ 'a', 'n', 'd', '.', 'l', 't', 32, 0,
  /* 293 */ 'o', 'r', '.', 'l', 't', 32, 0,
  /* 300 */ 'n', 'o', 't', 32, 0,
  /* 305 */ 'a', 'n', 'd', '.', 'g', 'e', '.', 'u', 32, 0,
  /* 315 */ 'o', 'r', '.', 'g', 'e', '.', 'u', 32, 0,
  /* 324 */ 'a', 'n', 'd', '.', 'l', 't', '.', 'u', 32, 0,
  /* 334 */ 'o', 'r', '.', 'l', 't', '.', 'u', 32, 0,
  /* 343 */ 'm', 'o', 'v', '.', 'u', 32, 0,
  /* 350 */ 'l', 'd', '.', 'b', 'u', 32, 0,
  /* 357 */ 'l', 'd', '.', 'h', 'u', 32, 0,
  /* 364 */ 'm', 'o', 'v', 32, 0,
  /* 369 */ 'l', 'd', '.', 'w', 32, 0,
  /* 375 */ 's', 't', '.', 'w', 32, 0,
  /* 381 */ 's', 'u', 'b', 'x', 32, 0,
  /* 387 */ 'a', 'd', 'd', 'x', 32, 0,
  /* 393 */ 'j', 'z', 32, 0,
  /* 397 */ 'j', 'n', 'z', 32, 0,
  /* 402 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
  /* 415 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 422 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 432 */ '#', 32, 'S', 'e', 'l', 'e', 'c', 't', '8', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 449 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
  /* 464 */ '#', '#', 'N', 'A', 'M', 'E', '#', '#', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 480 */ 'S', 'U', 'B', 'i', '6', '4', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 494 */ 'A', 'D', 'D', 'i', '6', '4', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 508 */ 'A', 'D', 'D', 'i', '6', '4', 'C', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 523 */ 'r', 'e', 't', 0,
  };

  // Emit the opcode for the instruction.
  uint32_t Bits = OpInfo[MCInst_getOpcode(MI)];
  // assert(Bits != 0 && "Cannot print this instruction.");
#ifndef CAPSTONE_DIET
  SStream_concat0(O, AsmStrs+(Bits & 1023)-1);
#endif


  if (strchr((const char *)AsmStrs+(Bits & 1023)-1, '[')) {
    set_mem_access(MI, true);
  }

  // Fragment 0 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 10) & 7) {
  default: // unreachable.
  case 0:
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END, ADDi64, ADDi64C, ANDN...
    return;
    break;
  case 1:
    // ABS, ADDArr, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADDrc, ADDrr, AD...
    printOperand(MI, 0, O);
    break;
  case 2:
    // ANDsc, ORsc, SUBAsc
    printZExtImm(MI, 0, O);
    return;
    break;
  case 3:
    // JNZsbr, JZsbr
    printOperand(MI, 1, O);
    SStream_concat0(O, ", ");
    printPCRelImmOperand(MI, 0, O);
    return;
    break;
  case 4:
    // Jb
    printPCRelImmOperand(MI, 0, O);
    return;
    break;
  case 5:
    // STAbo, STBbo, STDbo, STHbo, STWbo
    printAddrModeMemSrc(MI, 1, O);
    SStream_concat0(O, ", ");
    printOperand(MI, 0, O);
    return;
    break;
  }


  // Fragment 1 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 13) & 1) {
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, CALLb, NOTsr, RSUBsr
    return;
  } else {
    // ABS, ADDArr, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADDrc, ADDrr, AD...
    SStream_concat0(O, ", ");
  }


  // Fragment 2 encoded into 3 bits for 8 unique commands.
  switch ((Bits >> 14) & 7) {
  default: // unreachable.
  case 0:
    // ABS, ADDArr, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADDrc, ADDrr, AN...
    printOperand(MI, 1, O);
    break;
  case 1:
    // ADDsrc
    printSExtImm(MI, 2, O);
    return;
    break;
  case 2:
    // ADDsrr, AND_EQrc, AND_EQrr, AND_GEUrc, AND_GE_Urr, AND_GErc, AND_LTUrc...
    printOperand(MI, 2, O);
    break;
  case 3:
    // IMASKrcpw
    printZExtImm(MI, 1, O);
    SStream_concat0(O, ", ");
    printOperand(MI, 2, O);
    SStream_concat0(O, ", ");
    printOperand(MI, 3, O);
    return;
    break;
  case 4:
    // LDBUbo, LDBbo, LDDbo, LDHUbo, LDHbo, LDWbo
    printAddrModeMemSrc(MI, 1, O);
    return;
    break;
  case 5:
    // MOVUrlc
    printZExtImm(MI, 1, O);
    return;
    break;
  case 6:
    // MOVrlc
    printSExtImm(MI, 1, O);
    return;
    break;
  case 7:
    // MOVsrc
    printSExtImm(MI, 1, O);
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 17) & 3) {
  default: // unreachable.
  case 0:
    // ABS, ADDsrr, ANDsrr, MOVAArr, MOVAAsrr, MOVArr, MOVDrr, MOVHrlc, MOVrr...
    return;
    break;
  case 1:
    // ADDArr, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADDrc, ADDrr, AND_EQr...
    SStream_concat0(O, ", ");
    break;
  case 2:
    // ANDNrc, ORNrc, XNORrc
    SStream_concat0(O, ", ~(");
    printOperand(MI, 2, O);
    SStream_concat0(O, ")");
    return;
    break;
  }


  // Fragment 4 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 19) & 7) {
  default: // unreachable.
  case 0:
    // ADDArr, ADDCrr, ADDIrlc, ADDXrr, ADDrc, ADDrr, ANDrr, DEXTRrrpw, EQrr,...
    printOperand(MI, 2, O);
    break;
  case 1:
    // ADDCrc, ADDXrc, EQrc, GErc, LTrc, MULrc, NErc, RSUBrc, SHArc, SHrc
    printSExtImm(MI, 2, O);
    return;
    break;
  case 2:
    // AND_EQrc, AND_GErc, AND_LTrc, OR_GErc, OR_LTrc, OR_NErc
    printSExtImm(MI, 3, O);
    return;
    break;
  case 3:
    // AND_EQrr, AND_GE_Urr, AND_LT_Urr, OR_GErr, OR_LTrr, OR_NErr
    printOperand(MI, 3, O);
    return;
    break;
  case 4:
    // AND_GEUrc, AND_LTUrc, OR_GEUrc, OR_LTUrc
    printZExtImm(MI, 3, O);
    return;
    break;
  case 5:
    // ANDrc, NANDrc, NORrc, ORrc, XORrc
    printZExtImm(MI, 2, O);
    return;
    break;
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 22) & 1) {
    // DEXTRrrpw, EXTRrrpw
    SStream_concat0(O, ", ");
    printOperand(MI, 3, O);
    return;
  } else {
    // ADDArr, ADDCrr, ADDIrlc, ADDXrr, ADDrc, ADDrr, ANDrr, EQrr, GErr, LTrr...
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
static char *getRegisterName(unsigned RegNo)
{
  // assert(RegNo && RegNo < 17 && "Invalid register number!");

#ifndef CAPSTONE_DIET
  static char AsmStrs[] = {
  /* 0 */ 'A', '1', '0', 0,
  /* 4 */ 'D', '1', '0', 0,
  /* 8 */ 'E', '1', '0', 0,
  /* 12 */ 'A', '0', 0,
  /* 15 */ 'D', '0', 0,
  /* 18 */ 'E', '0', 0,
  /* 21 */ 'A', '1', '1', 0,
  /* 25 */ 'D', '1', '1', 0,
  /* 29 */ 'A', '1', 0,
  /* 32 */ 'D', '1', 0,
  /* 35 */ 'A', '1', '2', 0,
  /* 39 */ 'D', '1', '2', 0,
  /* 43 */ 'E', '1', '2', 0,
  /* 47 */ 'A', '2', 0,
  /* 50 */ 'D', '2', 0,
  /* 53 */ 'E', '2', 0,
  /* 56 */ 'A', '1', '3', 0,
  /* 60 */ 'D', '1', '3', 0,
  /* 64 */ 'A', '3', 0,
  /* 67 */ 'D', '3', 0,
  /* 70 */ 'A', '1', '4', 0,
  /* 74 */ 'D', '1', '4', 0,
  /* 78 */ 'E', '1', '4', 0,
  /* 82 */ 'A', '4', 0,
  /* 85 */ 'D', '4', 0,
  /* 88 */ 'E', '4', 0,
  /* 91 */ 'A', '1', '5', 0,
  /* 95 */ 'D', '1', '5', 0,
  /* 99 */ 'A', '5', 0,
  /* 102 */ 'D', '5', 0,
  /* 105 */ 'A', '6', 0,
  /* 108 */ 'D', '6', 0,
  /* 111 */ 'E', '6', 0,
  /* 114 */ 'A', '7', 0,
  /* 117 */ 'D', '7', 0,
  /* 120 */ 'A', '8', 0,
  /* 123 */ 'D', '8', 0,
  /* 126 */ 'E', '8', 0,
  /* 129 */ 'A', '9', 0,
  /* 132 */ 'D', '9', 0,
  /* 135 */ 'P', 'C', 0,
  /* 138 */ 'P', 'C', 'X', 'I', 0,
  /* 143 */ 'P', 'S', 'W', 0,
  /* 147 */ 'F', 'C', 'X', 0,
  };

  static const uint8_t RegAsmOffset[] = {
    147, 135, 138, 143, 12, 29, 47, 64, 82, 99, 105, 114, 120, 129,
    0, 21, 35, 56, 70, 91, 15, 32, 50, 67, 85, 102, 108, 117,
    123, 132, 4, 25, 39, 60, 74, 95, 18, 53, 88, 111, 126, 8,
    43, 78,
  };

  //assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
  //        "Invalid alt name index for register!");

  return AsmStrs+RegAsmOffset[RegNo-1];
#else
  return NULL;
#endif
}
