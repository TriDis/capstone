/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#include <stdio.h>	// debug
#include <platform.h>


/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
static void printInstruction(MCInst *MI, SStream *O, MCRegisterInfo *MRI)
{
  static const uint32_t OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    444U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    437U,	// BUNDLE
    471U,	// LIFETIME_START
    424U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_LOAD_OP
    1326U,	// ABS
    132197U,	// ADDArr
    394398U,	// ADDCrc
    132254U,	// ADDCrr
    132334U,	// ADDIrlc
    394649U,	// ADDXrc
    132505U,	// ADDXrr
    516U,	// ADDi64
    530U,	// ADDi64C
    132279U,	// ADDrc
    132279U,	// ADDrr
    17591U,	// ADDsrc
    33975U,	// ADDsrr
    9272U,	// ADJCALLSTACKDOWN
    9292U,	// ADJCALLSTACKUP
    132361U,	// ANDNrc
    486U,	// ANDNrc64
    689428U,	// AND_EQrc
    951572U,	// AND_EQrr
    1213767U,	// AND_GEUrc
    951623U,	// AND_GE_Urr
    689346U,	// AND_GErc
    1213786U,	// AND_LTUrc
    951642U,	// AND_LT_Urr
    689459U,	// AND_LTrc
    1443005U,	// ANDrc
    486U,	// ANDrc64
    132285U,	// ANDrr
    2062U,	// ANDsc
    33981U,	// ANDsrr
    486U,	// ANDsrr64
    9470U,	// CALLb
    2229543U,	// DEXTRrrpw
    394520U,	// EQrc
    132376U,	// EQrr
    2229544U,	// EXTRrrpw
    394438U,	// GErc
    132294U,	// GErr
    50423U,	// IMASKrcpw
    3117U,	// JNZsb
    4515U,	// JNZsbr
    3107U,	// JZsb
    4511U,	// JZsbr
    3316U,	// Jb
    66932U,	// LDBUbo
    66694U,	// LDBbo
    66724U,	// LDDbo
    66939U,	// LDHUbo
    66776U,	// LDHbo
    66951U,	// LDWbo
    66951U,	// LDWbol
    394551U,	// LTrc
    132407U,	// LTrr
    1145U,	// MOVAArr
    1145U,	// MOVAAsrr
    1138U,	// MOVArr
    1200U,	// MOVDrr
    1256U,	// MOVHrlc
    83309U,	// MOVUrlc
    486U,	// MOVi32
    99714U,	// MOVrlc
    1410U,	// MOVrr
    116098U,	// MOVsrc
    394500U,	// MULrc
    132356U,	// MULrr2
    34052U,	// MULsrr
    1443004U,	// NANDrc
    132284U,	// NANDrr
    394452U,	// NErc
    132308U,	// NErr
    1443101U,	// NORrc
    132381U,	// NORrr
    486U,	// NOTrr64
    9538U,	// NOTsr
    132367U,	// ORNrc
    486U,	// ORNrc64
    1213777U,	// OR_GEUrc
    689354U,	// OR_GErc
    951498U,	// OR_GErr
    1213796U,	// OR_LTUrc
    689467U,	// OR_LTrc
    951611U,	// OR_LTrr
    689361U,	// OR_NErc
    951505U,	// OR_NErr
    1443102U,	// ORrc
    486U,	// ORrc64
    132382U,	// ORrr
    2073U,	// ORsc
    34078U,	// ORsrr
    486U,	// ORsrr64
    545U,	// RET
    394386U,	// RSUBrc
    9362U,	// RSUBsr
    394369U,	// SHArc
    132225U,	// SHArr
    394468U,	// SHrc
    132324U,	// SHrr
    5228U,	// STAbo
    5260U,	// STBbo
    5290U,	// STDbo
    5342U,	// STHbo
    5517U,	// STWbo
    132190U,	// SUBArr
    2049U,	// SUBAsc
    132248U,	// SUBCrr
    132499U,	// SUBXrr
    502U,	// SUBi64
    454U,	// Select8
    132380U,	// XNORrc
    1443106U,	// XORrc
    486U,	// XORrc64
    486U,	// XORrcneg64
    132386U,	// XORrr
    132386U,	// XORsrr
    486U,	// XORsrr64
    0U
  };

  static char AsmStrs[] = {
  /* 0 */ 's', 'u', 'b', '.', 'a', 32, '%', 'a', '1', '0', ',', 32, 0,
  /* 13 */ 'a', 'n', 'd', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 24 */ 'o', 'r', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 34 */ 'j', 'z', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 44 */ 'j', 'n', 'z', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 55 */ '#', 32, 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 32, 0,
  /* 75 */ '#', 32, 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 32, 0,
  /* 93 */ 's', 'u', 'b', '.', 'a', 32, 0,
  /* 100 */ 'a', 'd', 'd', '.', 'a', 32, 0,
  /* 107 */ 's', 't', '.', 'a', 32, 0,
  /* 113 */ 'm', 'o', 'v', '.', 'a', 32, 0,
  /* 120 */ 'm', 'o', 'v', '.', 'a', 'a', 32, 0,
  /* 128 */ 's', 'h', 'a', 32, 0,
  /* 133 */ 'l', 'd', '.', 'b', 32, 0,
  /* 139 */ 's', 't', '.', 'b', 32, 0,
  /* 145 */ 'r', 's', 'u', 'b', 32, 0,
  /* 151 */ 's', 'u', 'b', 'c', 32, 0,
  /* 157 */ 'a', 'd', 'd', 'c', 32, 0,
  /* 163 */ 'l', 'd', '.', 'd', 32, 0,
  /* 169 */ 's', 't', '.', 'd', 32, 0,
  /* 175 */ 'm', 'o', 'v', '.', 'd', 32, 0,
  /* 182 */ 'a', 'd', 'd', 32, 0,
  /* 187 */ 'n', 'a', 'n', 'd', 32, 0,
  /* 193 */ 'a', 'n', 'd', '.', 'g', 'e', 32, 0,
  /* 201 */ 'o', 'r', '.', 'g', 'e', 32, 0,
  /* 208 */ 'o', 'r', '.', 'n', 'e', 32, 0,
  /* 215 */ 'l', 'd', '.', 'h', 32, 0,
  /* 221 */ 's', 't', '.', 'h', 32, 0,
  /* 227 */ 's', 'h', 32, 0,
  /* 231 */ 'm', 'o', 'v', 'h', 32, 0,
  /* 237 */ 'a', 'd', 'd', 'i', 32, 0,
  /* 243 */ 'j', 32, 0,
  /* 246 */ 'i', 'm', 'a', 's', 'k', 32, 0,
  /* 253 */ 'c', 'a', 'l', 'l', 32, 0,
  /* 259 */ 'm', 'u', 'l', 32, 0,
  /* 264 */ 'a', 'n', 'd', 'n', 32, 0,
  /* 270 */ 'o', 'r', 'n', 32, 0,
  /* 275 */ 'a', 'n', 'd', '.', 'e', 'q', 32, 0,
  /* 283 */ 'x', 'n', 'o', 'r', 32, 0,
  /* 289 */ 'x', 'o', 'r', 32, 0,
  /* 294 */ 'd', 'e', 'x', 't', 'r', 32, 0,
  /* 301 */ 'a', 'b', 's', 32, 0,
  /* 306 */ 'a', 'n', 'd', '.', 'l', 't', 32, 0,
  /* 314 */ 'o', 'r', '.', 'l', 't', 32, 0,
  /* 321 */ 'n', 'o', 't', 32, 0,
  /* 326 */ 'a', 'n', 'd', '.', 'g', 'e', '.', 'u', 32, 0,
  /* 336 */ 'o', 'r', '.', 'g', 'e', '.', 'u', 32, 0,
  /* 345 */ 'a', 'n', 'd', '.', 'l', 't', '.', 'u', 32, 0,
  /* 355 */ 'o', 'r', '.', 'l', 't', '.', 'u', 32, 0,
  /* 364 */ 'm', 'o', 'v', '.', 'u', 32, 0,
  /* 371 */ 'l', 'd', '.', 'b', 'u', 32, 0,
  /* 378 */ 'l', 'd', '.', 'h', 'u', 32, 0,
  /* 385 */ 'm', 'o', 'v', 32, 0,
  /* 390 */ 'l', 'd', '.', 'w', 32, 0,
  /* 396 */ 's', 't', '.', 'w', 32, 0,
  /* 402 */ 's', 'u', 'b', 'x', 32, 0,
  /* 408 */ 'a', 'd', 'd', 'x', 32, 0,
  /* 414 */ 'j', 'z', 32, 0,
  /* 418 */ 'j', 'n', 'z', 32, 0,
  /* 423 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
  /* 436 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 443 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 453 */ '#', 32, 'S', 'e', 'l', 'e', 'c', 't', '8', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 470 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
  /* 485 */ '#', '#', 'N', 'A', 'M', 'E', '#', '#', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 501 */ 'S', 'U', 'B', 'i', '6', '4', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 515 */ 'A', 'D', 'D', 'i', '6', '4', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 529 */ 'A', 'D', 'D', 'i', '6', '4', 'C', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 544 */ 'r', 'e', 't', 0,
  };

  // Emit the opcode for the instruction.
  uint32_t Bits = OpInfo[MCInst_getOpcode(MI)];
  // assert(Bits != 0 && "Cannot print this instruction.");
#ifndef CAPSTONE_DIET
  SStream_concat0(O, AsmStrs+(Bits & 1023)-1);
#endif


  if (strchr((const char *)AsmStrs+(Bits & 1023)-1, '[')) {
    set_mem_access(MI, true);
  }

  // Fragment 0 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 10) & 7) {
  default: // unreachable.
  case 0:
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END, ADDi64, ADDi64C, ANDN...
    return;
    break;
  case 1:
    // ABS, ADDArr, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADDrc, ADDrr, AD...
    printOperand(MI, 0, O);
    break;
  case 2:
    // ANDsc, ORsc, SUBAsc
    printZExtImm(MI, 0, O);
    return;
    break;
  case 3:
    // JNZsb, JZsb, Jb
    printPCRelImmOperand(MI, 0, O);
    return;
    break;
  case 4:
    // JNZsbr, JZsbr
    printOperand(MI, 1, O);
    SStream_concat0(O, ", ");
    printPCRelImmOperand(MI, 0, O);
    return;
    break;
  case 5:
    // STAbo, STBbo, STDbo, STHbo, STWbo
    printAddrModeMemSrc(MI, 1, O);
    SStream_concat0(O, ", ");
    printOperand(MI, 0, O);
    return;
    break;
  }


  // Fragment 1 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 13) & 1) {
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, CALLb, NOTsr, RSUBsr
    return;
  } else {
    // ABS, ADDArr, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADDrc, ADDrr, AD...
    SStream_concat0(O, ", ");
  }


  // Fragment 2 encoded into 3 bits for 8 unique commands.
  switch ((Bits >> 14) & 7) {
  default: // unreachable.
  case 0:
    // ABS, ADDArr, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADDrc, ADDrr, AN...
    printOperand(MI, 1, O);
    break;
  case 1:
    // ADDsrc
    printSExtImm(MI, 2, O);
    return;
    break;
  case 2:
    // ADDsrr, AND_EQrc, AND_EQrr, AND_GEUrc, AND_GE_Urr, AND_GErc, AND_LTUrc...
    printOperand(MI, 2, O);
    break;
  case 3:
    // IMASKrcpw
    printZExtImm(MI, 1, O);
    SStream_concat0(O, ", ");
    printOperand(MI, 2, O);
    SStream_concat0(O, ", ");
    printOperand(MI, 3, O);
    return;
    break;
  case 4:
    // LDBUbo, LDBbo, LDDbo, LDHUbo, LDHbo, LDWbo, LDWbol
    printAddrModeMemSrc(MI, 1, O);
    return;
    break;
  case 5:
    // MOVUrlc
    printZExtImm(MI, 1, O);
    return;
    break;
  case 6:
    // MOVrlc
    printSExtImm(MI, 1, O);
    return;
    break;
  case 7:
    // MOVsrc
    printSExtImm(MI, 1, O);
    return;
    break;
  }


  // Fragment 3 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 17) & 1) {
    // ADDArr, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADDrc, ADDrr, ANDNrc,...
    SStream_concat0(O, ", ");
  } else {
    // ABS, ADDsrr, ANDsrr, MOVAArr, MOVAAsrr, MOVArr, MOVDrr, MOVHrlc, MOVrr...
    return;
  }


  // Fragment 4 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 18) & 7) {
  default: // unreachable.
  case 0:
    // ADDArr, ADDCrr, ADDIrlc, ADDXrr, ADDrc, ADDrr, ANDNrc, ANDrr, DEXTRrrp...
    printOperand(MI, 2, O);
    break;
  case 1:
    // ADDCrc, ADDXrc, EQrc, GErc, LTrc, MULrc, NErc, RSUBrc, SHArc, SHrc
    printSExtImm(MI, 2, O);
    return;
    break;
  case 2:
    // AND_EQrc, AND_GErc, AND_LTrc, OR_GErc, OR_LTrc, OR_NErc
    printSExtImm(MI, 3, O);
    return;
    break;
  case 3:
    // AND_EQrr, AND_GE_Urr, AND_LT_Urr, OR_GErr, OR_LTrr, OR_NErr
    printOperand(MI, 3, O);
    return;
    break;
  case 4:
    // AND_GEUrc, AND_LTUrc, OR_GEUrc, OR_LTUrc
    printZExtImm(MI, 3, O);
    return;
    break;
  case 5:
    // ANDrc, NANDrc, NORrc, ORrc, XORrc
    printZExtImm(MI, 2, O);
    return;
    break;
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 21) & 1) {
    // DEXTRrrpw, EXTRrrpw
    SStream_concat0(O, ", ");
    printOperand(MI, 3, O);
    return;
  } else {
    // ADDArr, ADDCrr, ADDIrlc, ADDXrr, ADDrc, ADDrr, ANDNrc, ANDrr, EQrr, GE...
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
static char *getRegisterName(unsigned RegNo)
{
  // assert(RegNo && RegNo < 45 && "Invalid register number!");

#ifndef CAPSTONE_DIET
  static char AsmStrs[] = {
  /* 0 */ 'a', '1', '0', 0,
  /* 4 */ 'd', '1', '0', 0,
  /* 8 */ 'e', '1', '0', 0,
  /* 12 */ 'a', '0', 0,
  /* 15 */ 'd', '0', 0,
  /* 18 */ 'e', '0', 0,
  /* 21 */ 'a', '1', '1', 0,
  /* 25 */ 'd', '1', '1', 0,
  /* 29 */ 'a', '1', 0,
  /* 32 */ 'd', '1', 0,
  /* 35 */ 'a', '1', '2', 0,
  /* 39 */ 'd', '1', '2', 0,
  /* 43 */ 'e', '1', '2', 0,
  /* 47 */ 'a', '2', 0,
  /* 50 */ 'd', '2', 0,
  /* 53 */ 'e', '2', 0,
  /* 56 */ 'a', '1', '3', 0,
  /* 60 */ 'd', '1', '3', 0,
  /* 64 */ 'a', '3', 0,
  /* 67 */ 'd', '3', 0,
  /* 70 */ 'a', '1', '4', 0,
  /* 74 */ 'd', '1', '4', 0,
  /* 78 */ 'e', '1', '4', 0,
  /* 82 */ 'a', '4', 0,
  /* 85 */ 'd', '4', 0,
  /* 88 */ 'e', '4', 0,
  /* 91 */ 'a', '1', '5', 0,
  /* 95 */ 'd', '1', '5', 0,
  /* 99 */ 'a', '5', 0,
  /* 102 */ 'd', '5', 0,
  /* 105 */ 'a', '6', 0,
  /* 108 */ 'd', '6', 0,
  /* 111 */ 'e', '6', 0,
  /* 114 */ 'a', '7', 0,
  /* 117 */ 'd', '7', 0,
  /* 120 */ 'a', '8', 0,
  /* 123 */ 'd', '8', 0,
  /* 126 */ 'e', '8', 0,
  /* 129 */ 'a', '9', 0,
  /* 132 */ 'd', '9', 0,
  /* 135 */ 'p', 'c', 0,
  /* 138 */ 'p', 'c', 'x', 'i', 0,
  /* 143 */ 'p', 's', 'w', 0,
  /* 147 */ 'f', 'c', 'x', 0,
  };

  static const uint8_t RegAsmOffset[] = {
    147, 135, 138, 143, 12, 29, 47, 64, 82, 99, 105, 114, 120, 129,
    0, 21, 35, 56, 70, 91, 15, 32, 50, 67, 85, 102, 108, 117,
    123, 132, 4, 25, 39, 60, 74, 95, 18, 53, 88, 111, 126, 8,
    43, 78,
  };

  //assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
  //        "Invalid alt name index for register!");

  return AsmStrs+RegAsmOffset[RegNo-1];
#else
  return NULL;
#endif
}
