/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Assembly Writer Source Fragment                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#include <stdio.h>	// debug
#include <platform.h>


/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
static void printInstruction(MCInst *MI, SStream *O, MCRegisterInfo *MRI)
{
  static const uint32_t OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    465U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    458U,	// BUNDLE
    492U,	// LIFETIME_START
    445U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    0U,	// STATEPOINT
    0U,	// LOCAL_ESCAPE
    0U,	// FAULTING_LOAD_OP
    1344U,	// ABS
    263326U,	// ADDCrc
    787614U,	// ADDCrr
    787704U,	// ADDIrlc
    263598U,	// ADDXrc
    787886U,	// ADDXrr
    787557U,	// ADD_Arr
    537U,	// ADDi64
    551U,	// ADDi64C
    787639U,	// ADDrc
    787639U,	// ADDrr
    17591U,	// ADDsrc
    33975U,	// ADDsrr
    9272U,	// ADJCALLSTACKDOWN
    9292U,	// ADJCALLSTACKUP
    787731U,	// ANDNrc
    507U,	// ANDNrc64
    1344798U,	// AND_EQrc
    1869086U,	// AND_EQrr
    2393434U,	// AND_GE_Urc
    1869146U,	// AND_GE_Urr
    1344706U,	// AND_GErc
    1868994U,	// AND_GErr
    2393454U,	// AND_LT_Urc
    1869166U,	// AND_LT_Urr
    1344837U,	// AND_LTrc
    1869125U,	// AND_LTrr
    1344722U,	// AND_NErc
    1869010U,	// AND_NErr
    2884797U,	// ANDrc
    507U,	// ANDrc64
    787645U,	// ANDrr
    2062U,	// ANDsc
    33981U,	// ANDsrr
    507U,	// ANDsrr64
    9480U,	// CALLb
    4982073U,	// DEXTRrrpw
    263458U,	// EQrc
    787746U,	// EQrr
    4982074U,	// EXTRrrpw
    263366U,	// GErc
    787654U,	// GErr
    50433U,	// IMASKrcpw
    3117U,	// JNZsb
    67000U,	// JNZsbr
    3107U,	// JZsb
    66996U,	// JZsbr
    3326U,	// Jb
    83337U,	// LD_BUbo
    83078U,	// LD_Bbo
    83108U,	// LD_Dbo
    83344U,	// LD_HUbo
    83170U,	// LD_Hbo
    83356U,	// LD_Wbo
    83356U,	// LD_Wbol
    263497U,	// LTrc
    787785U,	// LTrr
    1266U,	// MOVHrlc
    1145U,	// MOV_AArr
    1145U,	// MOV_AAsrr
    1138U,	// MOV_Arr
    1200U,	// MOV_Drr
    99714U,	// MOV_Urlc
    507U,	// MOVi32
    116119U,	// MOVrlc
    1431U,	// MOVrr
    132503U,	// MOVsrc
    263438U,	// MULrc
    787726U,	// MULrr2
    34062U,	// MULsrr
    2884796U,	// NANDrc
    787644U,	// NANDrr
    263382U,	// NErc
    787670U,	// NErr
    2884911U,	// NORrc
    787759U,	// NORrr
    507U,	// NOTrr64
    9557U,	// NOTsr
    787737U,	// ORNrc
    507U,	// ORNrc64
    1344807U,	// OR_EQrc
    1869095U,	// OR_EQrr
    2393445U,	// OR_GE_Urc
    1869157U,	// OR_GE_Urr
    1344715U,	// OR_GErc
    1869003U,	// OR_GErr
    2393465U,	// OR_LT_Urc
    1869177U,	// OR_LT_Urr
    1344846U,	// OR_LTrc
    1869134U,	// OR_LTrr
    1344731U,	// OR_NErc
    1869019U,	// OR_NErr
    2884912U,	// ORrc
    507U,	// ORrc64
    787760U,	// ORrr
    2073U,	// ORsc
    34096U,	// ORsrr
    507U,	// ORsrr64
    566U,	// RET
    263314U,	// RSUBrc
    9362U,	// RSUBsr
    263297U,	// SHArc
    787585U,	// SHArr
    263406U,	// SHrc
    787694U,	// SHrr
    4204U,	// ST_Abo
    4236U,	// ST_Bbo
    4266U,	// ST_Dbo
    4328U,	// ST_Hbo
    4514U,	// ST_Wbo
    787608U,	// SUBCrr
    787880U,	// SUBXrr
    787550U,	// SUB_Arr
    2049U,	// SUB_Asc
    523U,	// SUBi64
    475U,	// Select8
    787758U,	// XNORrc
    1344806U,	// XOR_EQrc
    1869094U,	// XOR_EQrr
    2393444U,	// XOR_GE_Urc
    1869156U,	// XOR_GE_Urr
    1344714U,	// XOR_GErc
    1869002U,	// XOR_GErr
    2393464U,	// XOR_LT_Urc
    1869176U,	// XOR_LT_Urr
    1344845U,	// XOR_LTrc
    1869133U,	// XOR_LTrr
    1344730U,	// XOR_NErc
    1869018U,	// XOR_NErr
    2884916U,	// XORrc
    507U,	// XORrc64
    507U,	// XORrcneg64
    787764U,	// XORrr
    34100U,	// XORsrr
    507U,	// XORsrr64
    0U
  };

  static char AsmStrs[] = {
  /* 0 */ 's', 'u', 'b', '.', 'a', 32, '%', 'a', '1', '0', ',', 32, 0,
  /* 13 */ 'a', 'n', 'd', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 24 */ 'o', 'r', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 34 */ 'j', 'z', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 44 */ 'j', 'n', 'z', 32, '%', 'd', '1', '5', ',', 32, 0,
  /* 55 */ '#', 32, 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 32, 0,
  /* 75 */ '#', 32, 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 32, 0,
  /* 93 */ 's', 'u', 'b', '.', 'a', 32, 0,
  /* 100 */ 'a', 'd', 'd', '.', 'a', 32, 0,
  /* 107 */ 's', 't', '.', 'a', 32, 0,
  /* 113 */ 'm', 'o', 'v', '.', 'a', 32, 0,
  /* 120 */ 'm', 'o', 'v', '.', 'a', 'a', 32, 0,
  /* 128 */ 's', 'h', 'a', 32, 0,
  /* 133 */ 'l', 'd', '.', 'b', 32, 0,
  /* 139 */ 's', 't', '.', 'b', 32, 0,
  /* 145 */ 'r', 's', 'u', 'b', 32, 0,
  /* 151 */ 's', 'u', 'b', 'c', 32, 0,
  /* 157 */ 'a', 'd', 'd', 'c', 32, 0,
  /* 163 */ 'l', 'd', '.', 'd', 32, 0,
  /* 169 */ 's', 't', '.', 'd', 32, 0,
  /* 175 */ 'm', 'o', 'v', '.', 'd', 32, 0,
  /* 182 */ 'a', 'd', 'd', 32, 0,
  /* 187 */ 'n', 'a', 'n', 'd', 32, 0,
  /* 193 */ 'a', 'n', 'd', '.', 'g', 'e', 32, 0,
  /* 201 */ 'x', 'o', 'r', '.', 'g', 'e', 32, 0,
  /* 209 */ 'a', 'n', 'd', '.', 'n', 'e', 32, 0,
  /* 217 */ 'x', 'o', 'r', '.', 'n', 'e', 32, 0,
  /* 225 */ 'l', 'd', '.', 'h', 32, 0,
  /* 231 */ 's', 't', '.', 'h', 32, 0,
  /* 237 */ 's', 'h', 32, 0,
  /* 241 */ 'm', 'o', 'v', 'h', 32, 0,
  /* 247 */ 'a', 'd', 'd', 'i', 32, 0,
  /* 253 */ 'j', 32, 0,
  /* 256 */ 'i', 'm', 'a', 's', 'k', 32, 0,
  /* 263 */ 'c', 'a', 'l', 'l', 32, 0,
  /* 269 */ 'm', 'u', 'l', 32, 0,
  /* 274 */ 'a', 'n', 'd', 'n', 32, 0,
  /* 280 */ 'o', 'r', 'n', 32, 0,
  /* 285 */ 'a', 'n', 'd', '.', 'e', 'q', 32, 0,
  /* 293 */ 'x', 'o', 'r', '.', 'e', 'q', 32, 0,
  /* 301 */ 'x', 'n', 'o', 'r', 32, 0,
  /* 307 */ 'x', 'o', 'r', 32, 0,
  /* 312 */ 'd', 'e', 'x', 't', 'r', 32, 0,
  /* 319 */ 'a', 'b', 's', 32, 0,
  /* 324 */ 'a', 'n', 'd', '.', 'l', 't', 32, 0,
  /* 332 */ 'x', 'o', 'r', '.', 'l', 't', 32, 0,
  /* 340 */ 'n', 'o', 't', 32, 0,
  /* 345 */ 'a', 'n', 'd', '.', 'g', 'e', '.', 'u', 32, 0,
  /* 355 */ 'x', 'o', 'r', '.', 'g', 'e', '.', 'u', 32, 0,
  /* 365 */ 'a', 'n', 'd', '.', 'l', 't', '.', 'u', 32, 0,
  /* 375 */ 'x', 'o', 'r', '.', 'l', 't', '.', 'u', 32, 0,
  /* 385 */ 'm', 'o', 'v', '.', 'u', 32, 0,
  /* 392 */ 'l', 'd', '.', 'b', 'u', 32, 0,
  /* 399 */ 'l', 'd', '.', 'h', 'u', 32, 0,
  /* 406 */ 'm', 'o', 'v', 32, 0,
  /* 411 */ 'l', 'd', '.', 'w', 32, 0,
  /* 417 */ 's', 't', '.', 'w', 32, 0,
  /* 423 */ 's', 'u', 'b', 'x', 32, 0,
  /* 429 */ 'a', 'd', 'd', 'x', 32, 0,
  /* 435 */ 'j', 'z', 32, 0,
  /* 439 */ 'j', 'n', 'z', 32, 0,
  /* 444 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
  /* 457 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 464 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 474 */ '#', 32, 'S', 'e', 'l', 'e', 'c', 't', '8', 32, 'P', 'S', 'E', 'U', 'D', 'O', 0,
  /* 491 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
  /* 506 */ '#', '#', 'N', 'A', 'M', 'E', '#', '#', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 522 */ 'S', 'U', 'B', 'i', '6', '4', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 536 */ 'A', 'D', 'D', 'i', '6', '4', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 550 */ 'A', 'D', 'D', 'i', '6', '4', 'C', 32, 'P', 's', 'e', 'u', 'd', 'o', 0,
  /* 565 */ 'r', 'e', 't', 0,
  };

  // Emit the opcode for the instruction.
  uint32_t Bits = OpInfo[MCInst_getOpcode(MI)];
  // assert(Bits != 0 && "Cannot print this instruction.");
#ifndef CAPSTONE_DIET
  SStream_concat0(O, AsmStrs+(Bits & 1023)-1);
#endif


  if (strchr((const char *)AsmStrs+(Bits & 1023)-1, '[')) {
    set_mem_access(MI, true);
  }

  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 10) & 7) {
  default: // unreachable.
  case 0:
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END, ADDi64, ADDi64C, ANDN...
    return;
    break;
  case 1:
    // ABS, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADD_Arr, ADDrc, ADDrr, A...
    printOperand(MI, 0, O);
    break;
  case 2:
    // ANDsc, ORsc, SUB_Asc
    printZExtImm(MI, 0, O);
    return;
    break;
  case 3:
    // JNZsb, JZsb, Jb
    printPCRelImmOperand(MI, 0, O);
    return;
    break;
  case 4:
    // ST_Abo, ST_Bbo, ST_Dbo, ST_Hbo, ST_Wbo
    printAddrModeMemSrc(MI, 1, O);
    SStream_concat0(O, ", ");
    printOperand(MI, 0, O);
    return;
    break;
  }


  // Fragment 1 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 13) & 1) {
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, CALLb, NOTsr, RSUBsr
    return;
  } else {
    // ABS, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADD_Arr, ADDrc, ADDrr, A...
    SStream_concat0(O, ", ");
  }


  // Fragment 2 encoded into 4 bits for 9 unique commands.
  switch ((Bits >> 14) & 15) {
  default: // unreachable.
  case 0:
    // ABS, ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADD_Arr, ADDrc, ADDrr, A...
    printOperand(MI, 1, O);
    break;
  case 1:
    // ADDsrc
    printSExtImm(MI, 2, O);
    return;
    break;
  case 2:
    // ADDsrr, AND_EQrc, AND_EQrr, AND_GE_Urc, AND_GE_Urr, AND_GErc, AND_GErr...
    printOperand(MI, 2, O);
    break;
  case 3:
    // IMASKrcpw
    printZExtImm(MI, 1, O);
    SStream_concat0(O, ", ");
    printOperand(MI, 2, O);
    SStream_concat0(O, ", ");
    printOperand(MI, 3, O);
    return;
    break;
  case 4:
    // JNZsbr, JZsbr
    printPCRelImmOperand(MI, 1, O);
    return;
    break;
  case 5:
    // LD_BUbo, LD_Bbo, LD_Dbo, LD_HUbo, LD_Hbo, LD_Wbo, LD_Wbol
    printAddrModeMemSrc(MI, 1, O);
    return;
    break;
  case 6:
    // MOV_Urlc
    printZExtImm(MI, 1, O);
    return;
    break;
  case 7:
    // MOVrlc
    printSExtImm(MI, 1, O);
    return;
    break;
  case 8:
    // MOVsrc
    printSExtImm(MI, 1, O);
    return;
    break;
  }


  // Fragment 3 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 18) & 1) {
    // ADDCrc, ADDCrr, ADDIrlc, ADDXrc, ADDXrr, ADD_Arr, ADDrc, ADDrr, ANDNrc...
    SStream_concat0(O, ", ");
  } else {
    // ABS, ADDsrr, ANDsrr, MOVHrlc, MOV_AArr, MOV_AAsrr, MOV_Arr, MOV_Drr, M...
    return;
  }


  // Fragment 4 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 19) & 7) {
  default: // unreachable.
  case 0:
    // ADDCrc, ADDXrc, EQrc, GErc, LTrc, MULrc, NErc, RSUBrc, SHArc, SHrc
    printSExtImm(MI, 2, O);
    return;
    break;
  case 1:
    // ADDCrr, ADDIrlc, ADDXrr, ADD_Arr, ADDrc, ADDrr, ANDNrc, ANDrr, DEXTRrr...
    printOperand(MI, 2, O);
    break;
  case 2:
    // AND_EQrc, AND_GErc, AND_LTrc, AND_NErc, OR_EQrc, OR_GErc, OR_LTrc, OR_...
    printSExtImm(MI, 3, O);
    return;
    break;
  case 3:
    // AND_EQrr, AND_GE_Urr, AND_GErr, AND_LT_Urr, AND_LTrr, AND_NErr, OR_EQr...
    printOperand(MI, 3, O);
    return;
    break;
  case 4:
    // AND_GE_Urc, AND_LT_Urc, OR_GE_Urc, OR_LT_Urc, XOR_GE_Urc, XOR_LT_Urc
    printZExtImm(MI, 3, O);
    return;
    break;
  case 5:
    // ANDrc, NANDrc, NORrc, ORrc, XORrc
    printZExtImm(MI, 2, O);
    return;
    break;
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 22) & 1) {
    // DEXTRrrpw, EXTRrrpw
    SStream_concat0(O, ", ");
    printOperand(MI, 3, O);
    return;
  } else {
    // ADDCrr, ADDIrlc, ADDXrr, ADD_Arr, ADDrc, ADDrr, ANDNrc, ANDrr, EQrr, G...
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
static char *getRegisterName(unsigned RegNo)
{
  // assert(RegNo && RegNo < 45 && "Invalid register number!");

#ifndef CAPSTONE_DIET
  static char AsmStrs[] = {
  /* 0 */ 'a', '1', '0', 0,
  /* 4 */ 'd', '1', '0', 0,
  /* 8 */ 'e', '1', '0', 0,
  /* 12 */ 'a', '0', 0,
  /* 15 */ 'd', '0', 0,
  /* 18 */ 'e', '0', 0,
  /* 21 */ 'a', '1', '1', 0,
  /* 25 */ 'd', '1', '1', 0,
  /* 29 */ 'a', '1', 0,
  /* 32 */ 'd', '1', 0,
  /* 35 */ 'a', '1', '2', 0,
  /* 39 */ 'd', '1', '2', 0,
  /* 43 */ 'e', '1', '2', 0,
  /* 47 */ 'a', '2', 0,
  /* 50 */ 'd', '2', 0,
  /* 53 */ 'e', '2', 0,
  /* 56 */ 'a', '1', '3', 0,
  /* 60 */ 'd', '1', '3', 0,
  /* 64 */ 'a', '3', 0,
  /* 67 */ 'd', '3', 0,
  /* 70 */ 'a', '1', '4', 0,
  /* 74 */ 'd', '1', '4', 0,
  /* 78 */ 'e', '1', '4', 0,
  /* 82 */ 'a', '4', 0,
  /* 85 */ 'd', '4', 0,
  /* 88 */ 'e', '4', 0,
  /* 91 */ 'a', '1', '5', 0,
  /* 95 */ 'd', '1', '5', 0,
  /* 99 */ 'a', '5', 0,
  /* 102 */ 'd', '5', 0,
  /* 105 */ 'a', '6', 0,
  /* 108 */ 'd', '6', 0,
  /* 111 */ 'e', '6', 0,
  /* 114 */ 'a', '7', 0,
  /* 117 */ 'd', '7', 0,
  /* 120 */ 'a', '8', 0,
  /* 123 */ 'd', '8', 0,
  /* 126 */ 'e', '8', 0,
  /* 129 */ 'a', '9', 0,
  /* 132 */ 'd', '9', 0,
  /* 135 */ 'p', 'c', 0,
  /* 138 */ 'p', 'c', 'x', 'i', 0,
  /* 143 */ 'p', 's', 'w', 0,
  /* 147 */ 'f', 'c', 'x', 0,
  };

  static const uint8_t RegAsmOffset[] = {
    147, 135, 138, 143, 12, 29, 47, 64, 82, 99, 105, 114, 120, 129,
    0, 21, 35, 56, 70, 91, 15, 32, 50, 67, 85, 102, 108, 117,
    123, 132, 4, 25, 39, 60, 74, 95, 18, 53, 88, 111, 126, 8,
    43, 78,
  };

  //assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
  //        "Invalid alt name index for register!");

  return AsmStrs+RegAsmOffset[RegNo-1];
#else
  return NULL;
#endif
}
